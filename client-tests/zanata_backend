#!/usr/bin/env perl
#

=pod

=head1 NAME

zanata_backend - Unified zanata command line

=head1 SYNOPSIS

zanata_backend

zanata_backend E<lt>commandE<gt> [E<lt>optionsE<gt>] [-- E<lt>backend optionsE<gt>]

=head1 DESCRIPTION

The zanata_backend program provides an unified command line interface to
various zanata command-line clients, so switching between client are less painful.
A zanata command-line client will be referred as B<backend> later on.

This program just convert commands and options for backend, but not match
behavior amongst clients. For example:

    C<zanata_backend push> 

will converted to maven

    C<mvn org.zanata:zanata-maven-plugin:push>

which is sufficient to push source documents, but if C<zanata-cli> 
is the backend, then it get convert to 

    C<zanata-cli push>

which will fail, as C<push> in C<zanata-cli> requires 
C<--src-dir> and C<--trans-dir>.

So for end-user use, specified the options you need for consist ant result.

=head1 BACKENDS

Specify environment variable C<ZANATA_BACKEND>
for the backend you plan to use.

For example, to use zanata-java-client:

    C<export ZANATA_COMMAND_BACKEND=/usr/bin/zanata-cli>
or just if zanata-cli is in C<PATH>
    C<export ZANATA_COMMAND_BACKEND=zanata-cli>

If C<ZANATA_BACKEND> is not specified, it will get the first 
available command in PATH in following order:

=over 4

=item zanata-cli

=item mvn

=item zanata

=back


=head1 ARGUMENTS

If no command are given, this help is printed; 
otherwise the command will be converted for backend.

=head1 OPTIONS

There are 2 types of options: options from zanata commands,
and options for backend.

=head2 Zanata Command Options

zanata java/python client style options will be used. E.g.:

--project-name GCC --project-desc "GNU Compiler Collection"

=head2 Backend Options

Options after -- are backend options. 
Those options will be pass to backend as-is.

=head1 ENVIRONMENT VARIABLES

=over 4

=item C<ZANATA_BACKEND>: Specify the backend to be used.

=item C<ZANATA_BACKEND_DEBUG>
    0 for not showing debug message.
    1 for showing the actual command.

=item C<ZANATA_BACKEND_DRY_RUN>: Do not execute the command

=back

=cut

# Ensure it runs on RHEL5
use 5.008_008;
use strict;
use Data::Dumper;
use File::Basename;
use File::Spec;
use File::Which qw(which);
use Pod::Usage;
use autodie;
use constant MVN_COMMAND_PREFIX => "org.zanata:zanata-maven-plugin";

sub hyphen_to_camel_case{
    my ($optName)=@_;
    $optName=~ s/[-]([a-z])/uc($1)/ge;
    return $optName;
}

my %optionH;
my @optionA;
my %backendOptH;
my @backendOptA;

## Parse arguments
pod2usage(1) if @ARGV == 0;
my $command=shift @ARGV;
my $backendMode=0;
my $lastOptName=undef;
foreach my $a (@ARGV){
    if ($backendMode){
	push @backendOptA, $a;
    }else{
	if ($lastOptName){
	    $optionH{$lastOptName}=$a;
	    $lastOptName=undef;
	}else{
	    if ($a eq "--" ){
		$backendMode=1;
	    }elsif ( $a =~ m|^--.*| ){
		## long option
		$lastOptName= $a=~s/^--//;
		push @optionA, $lastOptName;
	    }elsif ( $a =~ m|^-.| ){
		## short option 
		$lastOptName= $a=~s/^-//;
		push @optionA, $lastOptName;
	    }else{
		die "Options need to be put in front of $a";
	    }	
	}
    }
}

## Determine the backend
my $zanataBackend=undef;
my $zanataCmd=undef;
if ($ENV{'ZANATA_BACKEND'}){
    my ($vol,$dir,$file) =File::Spec->splitpath($ENV{'ZANATA_BACKEND'});
    if ($dir){
	### Test file existence if dir is given
	unless ( -x $ENV{'ZANATA_BACKEND'}){
	    die "ERROR: " . $ENV{'ZANATA_BACKEND'} . " is not executable";
        }
	$zanataBackend=$file;
	$zanataCmd=$ENV{'ZANATA_BACKEND'};
    }else{
	### Otherwise use which to search
	my $which_result=which($ENV{'ZANATA_BACKEND'});
	unless ( $which_result ){
	    die "ERROR: " . $ENV{'ZANATA_BACKEND'} . " is not found.";
	}
	$zanataBackend=$file;
	$zanataCmd=$which_result;
    }
}else{
    foreach my $cmd (qw ( zanata-cli mvn zanata )){
	my $which_result=which($cmd);
	if ($which_result){
	    $zanataCmd=$which_result;
	    $zanataBackend=$cmd;
	    last;
	}
    }
    unless ($zanataCmd){
	die "ERROR: Zanata backends are not found, please install either zanata-cli, mvn or zanata";
    }
}

## Convert the command
if ($zanataBackend eq "mvn"){
    $command= MVN_COMMAND_PREFIX . ":$command";
}

## Convert the options
foreach my $o (@optionA){

}

## Print the command to be run
## Run command
print "command=$command backend=$zanataBackend\n";
exit 0;
## path variables
my $scriptDir=dirname($0);

## Definition
my $backupSuffix=".bak";
my $zanataNameSpace='http://zanata.org/namespace/config/';
my $command;
my @clientOptionA;
my $backendCmd;
my @cmdL;

my %commandPyGoalH=(
    'glossary-delete' => ''
    , 'glossary-push' => 'glossary push'
    , 'help-backend' => 'help'
    , 'list-remote' => ''
    , 'pull' => 'pull'
    , 'pull-module' => 'pull-module'
    , 'push' => 'push'
    , 'push-module' => 'push-module'
    , 'put-project' => 'project create'
    , 'put-user' => ''
    , 'put-version' => 'version create'
    , 'stat' => ''
);

my %zanata_backendOnlyOptH=(
    'backend' => 1
    , 'base-dir' => 1
    , 'batch' => 1
    , 'debug' => 1
    , 'errors' => 1
    , 'help-backend' => 1
    , 'quiet' => 1
    , 'show' => 1
);

my %optH;

my %optionConvertH={
    'put-project' => {
	'project' => 'project-slug'
	, 'project-type' => 'default-project-type'
    }
    , 'put-version' => { 
	'project-version' => 'version-slug'
	, 'project' => 'version-project'
    }
};

my %optionPyH=(
    'create-skeletons' => 'noskeletons'
    , 'copy-trans' => 'no-copytrans'
    , 'key' => 'apikey'
    , 'locales' => 'lang'
    , 'src-dir' => 'srcdir'
    , 'trans-dir' => 'transdir'
);

my @OptionA=(
    'key|api-key|k=s'
    , 'base-dir|b=s'
    , 'backend|c=s'
    , 'batch|B'
    , 'batch-size=i'
    , 'comment-cols=s'
    , 'debug|X'
    , 'document-id=s'
    , 'errors|e'
    , 'exclude=s'
    , 'file-types=s'
    , 'format=s'
    , 'from-doc=s'
    , 'glossary-file'
    , 'help|h'
    , 'help-backend|H'
    , 'include=s'
    , 'lang=s'
    , 'locales|l=s'
    , 'max-chunk-size=i'
    , 'merge-type|merge=s'
    , 'project|project-slug|version-project=s'
    , 'project-description=s'
    , 'project-type|t=s'
    , 'project-config=s'
    , 'push-type|p=s'
    , 'pull-type|P=s'
    , 'quiet|q'
    , 'show|S'
    , 'source-lang=s'
    , 'src-dir|s=s'
    , 'trans-dir|t=s'
    , 'trans-lang=s'
    , 'url|u=s'
    , 'user-config=s'
    , 'user-email=s'
    , 'user-key=s'
    , 'user-langs=s'
    , 'user-name=s'
    , 'user-password-hash=s'
    , 'user-roles=s'
    , 'user-username=s'
    , 'username|U=s'
    , 'validate=s'
    , 'project-version|version-slug|version=s'
);

GetOptions(\%optH,
    @OptionA
    , '<>' => \&parse_options
) or pod2usage(-1);
pod2usage() if @ARGV == 0;

###########################################################
# Parse options
#
my %clientCmdH=(
    maven => 'mvn'
    , python => 'zanata'
    , java => 'zanata-cli'
);

sub find_backend{
    my ($backend)=@_;
    my $envValue=$ENV{"ZANATA_" . uc($backend) . "_CLIENT"};
    if ($envValue){
	if (-x $envValue){
	    $optH{'backend'}=$backend;
	    return $envValue;
	}
    }
    my $cmd=`which $clientCmdH{$backend} 2>&-`;
    return undef unless $cmd;
    $optH{'backend'}=$backend;
    chomp($cmd);
    return $cmd;
}

my $isArgumentOpt=1;

sub parse_options{
    my ($opt)=@_;

    if ($opt eq '--'){
	$isArgumentOpt=0;
	return;
    }
    my $true=1;
    my $value=undef;

    if ($isArgumentOpt){
	if ($opt =~ /^-/){
	    if ($opt =~m/^no[-]?/){
		$opt=~ s/^no[-]?//;
		$true=0;
	    }
	    if ($opt =~ /=/){
		($opt, $value)=split('=', $opt, 2);
	    }
	    $opt =~ s/^-+//;
	    $optH{$opt}=(defined $value)? $value : $true;
	}elsif ($opt eq 'help'){
	    $optH{'help'}=1;
	}elsif ($opt eq 'help-backend'){
	    $optH{'help-backend'}=1;
	}else{
	    if ($command){
		push @clientOptionA, $opt;
	    }else{
		$command=$opt;
	    }
	}
    }else{
	push @clientOptionA, $opt;
    }
}

sub backend_help_command{
    my ($arg)=@_;
    my @cmdA=($backendCmd);
    if ($optH{'backend'} eq 'maven'){
	push @cmdA, "zanata:help";
	push @cmdA, "-Ddetail";
	if ($arg){
	    push @cmdA, "-Dgoal=$arg";
	}
    }elsif ($optH{'backend'} eq 'java' or $optH{'backend'} eq 'python'){
	push @cmdA, "help";
	if ($arg){
	    push @cmdA, "$arg";
	}
    }
    return join(' ', @cmdA);

}

sub print_backend_help{
    my ($arg)=@_;
    my $cmd=backend_help_command($arg);
    exit -1 unless $cmd;
    if ($optH{'show'}){
	print "Command: $cmd\n";
    }
    system($cmd);
    exit 0;
}

sub maven_help_parser{
    my ($content)=@_;
    my @lines=split /\n/, $content;
    my %resultH;
    my $start=0;
    my $opt;
    my $desc;
    for my $line (@lines){
	if ($start){
	    if ($opt){
		if ($line =~ /^\s+Expression: \$/){
		    $resultH{$opt}=$desc;
		    $opt=undef;
		    $desc=undef;
		}else{
		    trim($line);
		    $desc.=($line) ? " " . $line : "\n\n";
		}
	    }else{
		trim($line);
		next unless $line;
		next if $line =~ /^\[INFO\]/;
		$line=~s/\s.*$//g;
		$opt=camel_case_to_hyphen($line);
	    }
	}else{
	    if ($opt){
		if ($line =~ /\s+Available parameters:/){
		    $desc=~ s/\n+$/\n/;
		    $resultH{$opt}=$desc;
		    $opt=undef;
		    $desc=undef;
		    $start=1;
		}else{
		    trim($line);
		    $desc.=($line) ? " " . $line : "\n\n";
		}
	    }else{
		next unless $line =~ /^zanata:([a-zA-Z-]+)/;
		$opt=$1;
	    }
	}
    }
    return \%resultH;
}

sub print_help{
    my ($arg)=@_;
    my $cmd=backend_help_command($arg);
    exit -1 unless $cmd;
    my $helpText=`$cmd`;
    exit -1 unless $helpText;
    if ($optH{'backend'} eq 'maven'){
	my $helpHRef=maven_help_parser($helpText);
	if ($arg){
	    print "$arg\n";
	    print "\t" . $helpHRef->{$arg} . "\n\n";
	}
	print "Available parameters:\n\n";
	for my $opt (sort keys %$helpHRef){
	    next if ($opt eq $arg);
	    print "  $opt\n";
	    print "\t" . $helpHRef->{$opt} . "\n\n";
	}
    }elsif ($optH{'backend'} eq 'python'){
	while(my ($o, $v)=each %optionPyH){
	    $helpText=~s/$v/$o/mg;
	}
	print $helpText;
    }else{
	print $helpText;
    }
    exit 0;
}

foreach (@ARGV){
    parse_options($_);
}

## Determine the backend
if ($optH{'backend'}){
    $backendCmd=find_backend($optH{'backend'});
    die "[Error] Backend " . $optH{'backend'} . " is not installed\n" unless $backendCmd;
}elsif ($ENV{'ZANATA_BACKEND'}){
    $backendCmd=find_backend($ENV{'ZANATA_BACKEND'});
    die "[Error] Backend " . $ENV{'ZANATA_BACKEND'} . " is not installed\n" unless $backendCmd;
}else{
    for my $backend (qw(java maven python)){
	$backendCmd=find_backend($backend);
	last if $backendCmd;
    } 
    die "[Error] No Backend is installed." unless $backendCmd;
}

###########################################################
# Main program
#

#=========================================================
# Help
#
if (! $command){
    if ($optH{'help'}){
	pod2usage( {-verbose=>1, exitval=>0});
    }elsif($optH{'help-backend'}){
	print_backend_help;
    }else{
	print {*STDERR} "[Error] No command.\n";
	pod2usage( {-exitval=>1, -verbose=>1});
    }
}elsif ($optH{'help'}){
    print_help($command);
}elsif ($optH{'help-backend'}){
    print_backend_help($command);
}elsif(!defined $commandPyGoalH{$command}){
    print {*STDERR} "[Error] Unrecognized command: $command \n";
    pod2usage( {-exitval=>1});
}

sub get_option_type{
    my ($opt)=@_;
    for my $op (@OptionA){
	my ($oS, $t)=split('=',$op, 2);
	my @alias=split(/[|]/,$oS);
	for my $o (@alias){
	    return ($t) ? $t : 'b' if ($o eq $opt);
	}
    }
    return 'b';
}

sub add_option{
    my ($opt, $optType, $value)=@_;
    if ($optH{'backend'} eq 'maven'){
	$opt=hyphen_to_camel_case($opt);
	if ($optType eq 'b'){
	    if ($value){
		push @cmdL, "-Dzanata.$opt";
	    }else{
		push @cmdL, "-Dzanata.$opt=false";
	    }
	}elsif ($optType eq 'i'){
	    push @cmdL, "-Dzanata.$opt=$value";
	}else{
	    push @cmdL, "\"-Dzanata.$opt=$value\"";
	}
    }elsif($optH{'backend'} eq 'java'){
	push @cmdL, "--$opt";
	if ($optType eq 'b'){
	    push @cmdL, 'false' unless ($value);
	}elsif ($optType eq 'i'){
	    push @cmdL, $value;
	}else{
	    push @cmdL, "\"$value\"";
	}
    }elsif($optH{'backend'} eq 'python'){
	if ($optionPyH{$opt}){
	    $opt=$optionPyH{$opt};
	    if ($opt eq 'noskeletons'){
		return if ($value);
	    }elsif($opt eq 'no-copytrans'){
		return if ($value);
	    }
	}
	push @cmdL, "--$opt";
	if ($optType eq 'i'){
	    push @cmdL, $value;
	}elsif($optType eq 's'){
	    push @cmdL, "\"$value\"";
	}
    }
}

## Form command
push @cmdL, $backendCmd;

## Zanatac only options
if ($optH{'batch'}){
    if ($optH{'backend'} eq 'maven'){
	push @cmdL, '-B';
    }else{
	unshift @cmdL, 'yes', '|'
    }
}

if ($optH{'base-dir'}){
    unshift @cmdL, 'cd', $optH{'base-dir'}, '&&';
}

if ($optH{'debug'}){
    if ($optH{'backend'} ne 'python'){
	push @cmdL, '-X';
    }
}
if ($optH{'errors'}){
    if ($optH{'backend'} ne 'python'){
	push @cmdL, '-e';
    }
}

if ($optH{'backend'} eq 'maven'){
    push @cmdL, "zanata:$command";
}elsif($optH{'backend'} eq 'python'){
    my $pyArg=$commandPyGoalH{$command};
    unless($pyArg){
	die "[Error] zanata-python-client does not support $command.\n";
    }
    push @cmdL, $pyArg;
}else{
    push @cmdL, $command;
}

## Convert options
while(my ($opt, $value)=each %optH){
    unless ($zanata_backendOnlyOptH{$opt}){
	my $optType=get_option_type($opt);
	if ($optionConvertH{$command}{$opt}){
	    $opt=$optionConvertH{$command}{$opt};
	}

	add_option($opt, $optType, $value);
    }
}

## Concat passthough
push @cmdL, @clientOptionA;
my $cmdStr=join(' ', @cmdL);

## Execute command

## Show command if --show
if ($optH{'show'}){
    print "Command: $cmdStr\n";
}

## Execute command
system($cmdStr)==0 or die "Command run failed $?: $cmdStr";


=head1 AUTHOR

Ding-Yi Chen <dchen@redhat.com>

=cut
